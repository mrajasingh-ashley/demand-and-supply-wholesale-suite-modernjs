trigger:
  branches:
    include:
      - main
      - dev

variables:
  imageRepository: "afi/demand-planning/demand-planning-web"
  containerRegistry: "ashleyfurniture.azurecr.io"
  dockerfilePath: "Dockerfile"
  tag: "$(Build.BuildId)"

stages:
  # --- STAGE 1: BUILD A GENERIC IMAGE ---
  - stage: Build
    displayName: "Build Generic Application Image"
    jobs:
      - job: Build
        displayName: "Build"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          # The build process is now completely environment-agnostic.
          # It creates one image that can be deployed to any environment.
          - task: Docker@2
            displayName: "Build and Push Generic Docker Image"
            inputs:
              containerRegistry: "ashleyfurniture"
              repository: "$(imageRepository)"
              command: "buildAndPush"
              Dockerfile: "$(dockerfilePath)"
              buildContext: "$(Build.SourcesDirectory)"
              tags: |
                $(tag)
                latest

          # We publish the Kubernetes manifests as an artifact so the deploy stage can use them.
          - task: PublishBuildArtifacts@1
            displayName: "Publish Kubernetes Manifests"
            inputs:
              PathtoPublish: "$(Build.SourcesDirectory)/Kubernetes"
              ArtifactName: "kubernetes-manifests"
              publishLocation: "Container"

  - stage: Deploy_Dev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'dev'), eq(variables['Build.SourceBranchName'], 'main')))
    jobs:
      - deployment: DeployToDev
        displayName: "Deploy to Dev Kubernetes"
        environment: "afi-dev-kube.demand-planning"
        pool:
          vmImage: "ubuntu-latest"
        strategy:
          runOnce:
            deploy:
              steps:
                # Step 1: Download the Kubernetes manifests that were published by the Build stage.
                - task: DownloadBuildArtifacts@0
                  displayName: "Download Kubernetes manifests"
                  inputs:
                    buildType: "current"
                    downloadType: "single"
                    artifactName: "kubernetes-manifests"
                    downloadPath: "$(Pipeline.Workspace)"

                - task: KubernetesManifest@1
                  displayName: "Deploy to Dev Kubernetes"
                  inputs:
                    action: "deploy"
                    kubernetesServiceConnection: "dev-kube"
                    namespace: "demand-planning"
                    # This applies all our configuration files. The runtime injection happens inside the cluster.
                    manifests: "$(Pipeline.Workspace)/kubernetes-manifests/Dev/*.yaml"
                    containers: |
                      $(containerRegistry)/$(imageRepository):$(tag)

  - stage: Deploy_Stage
    displayName: "Deploy to Staging"
    dependsOn: Deploy_Dev
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'dev'), eq(variables['Build.SourceBranchName'], 'main')))
    jobs:
      - deployment: DeployToStage
        displayName: "Deploy to Stage Kubernetes"
        environment: "afi-stage-kube.demand-planning"
        pool:
          vmImage: "ubuntu-latest"
        strategy:
          runOnce:
            deploy:
              steps:
                # Step 1: Download the Kubernetes manifests that were published by the Build stage.
                - task: DownloadBuildArtifacts@0
                  displayName: "Download Kubernetes manifests"
                  inputs:
                    buildType: "current"
                    downloadType: "single"
                    artifactName: "kubernetes-manifests"
                    downloadPath: "$(Pipeline.Workspace)"

                - task: KubernetesManifest@1
                  displayName: "Deploy to Stage Kubernetes"
                  inputs:
                    action: "deploy"
                    kubernetesServiceConnection: "stage-kube"
                    namespace: "demand-planning"
                    # This applies all our configuration files. The runtime injection happens inside the cluster.
                    manifests: "$(Pipeline.Workspace)/kubernetes-manifests/Stage/*.yaml"
                    containers: |
                      $(containerRegistry)/$(imageRepository):$(tag)
